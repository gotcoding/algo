# 图

## 概念

一个图就是一些`顶点（vertex）`的集合，这些顶点通过一系列`边（edge）`连接。顶点用圆圈表示，边就是这些圆圈之间的连线，顶点之间通过边连接。顶点的`度（degree）`是跟顶点相连接的边的条数。在有向图中，我们把度分为`入度（In-degree）`表示有多少条边指向这个顶点，和`出度（Out-degree）`表示有多少条边是以这个顶点为起点指向其他顶点。QQ亲密度用到另一种图，`带权图（weighted graph）`。在带权图中，每条边都有一个权重（weight）。

## 存储方式

### 邻接矩阵
图最直观的一种存储方法就是`邻接矩阵（Adjacency Matrix）`。邻接矩阵的底层依赖一个二维数组。对于无向图来说，如果顶点 i 与顶点 j 之间有边，我们就将 A[i][j]和 A[j][i]标记为 1；对于有向图来说，如果顶点 i 到顶点 j 之间，有一条箭头从顶点 i 指向顶点 j 的边，那我们就将 A[i][j]标记为 1。同理，如果有一条箭头从顶点 j 指向顶点 i 的边，我们就将 A[j][i]标记为 1。对于带权图，数组中就存储相应的权重。


### 稀疏图
另一种存储的是稀疏图（Sparse Matrix），适合存储顶点很多，但每个顶点的边并不多的图。

### 邻接表
当邻接矩阵比较浪费内存空间时，我们来看另外一种图的存储方法，`邻接表（Adjacency List）`。

我们可以将邻接表中的链表改成平衡二叉查找树。实际开发中，我们可以选择用红黑树。这样，我们就可以更加快速地查找两个顶点之间是否存在边了。当然，这里的二叉查找树可以换成其他动态数据结构，比如跳表、散列表等。除此之外，我们还可以将链表改成有序动态数组，可以通过二分查找的方法来快速定位两个顶点之间否是存在边。


### 比较
邻接矩阵存储方法的缺点是比较浪费空间，但是优点是查询效率高，而且方便矩阵运算。邻接表存储方法中每个顶点都对应一个链表，存储与其相连接的其他顶点。尽管邻接表的存储方式比较节省存储空间，但链表不方便查找，所以查询效率没有邻接矩阵存储方式高。针对这个问题，邻接表还有改进升级版，即将链表换成更加高效的动态数据结构，比如平衡二叉查找树、跳表、散列表等。
