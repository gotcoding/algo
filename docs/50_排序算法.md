# 排序

* O(n^2)

冒泡、插入、旋转排序都是时间复杂度为 O(n2) 的排序算法，冒泡排序、选择排序，可能就纯粹停留在理论的层面了。这三种排序，对于小规模数据的排序，用起来非常高效。

* O(nlogn)

归并排序和快速排序是用的都是分治的思想，代码都通过递归来实现，过程非常相似。

归并排序的时间复杂度任何情况下都是 O(nlogn)，但不是原地排序算法，空间复杂度是 O(n)。

快排是一种原地、不稳定的排序算法，最坏情况下的时间复杂度是 O(n2)。

* O(n)

桶排序、计数排序、基数排序

桶排序和计数排序的排序思想是非常相似的，都是针对范围不大的数据，将数据划分成不同的桶来实现排序。
基数排序要求数据可以划分成高低位，位之间有递进关系。比较两个数，我们只需要比较高位，高位相同的再比较低位。而且每一位的数据范围不能太大，因为基数排序算法需要借助桶排序或者计数排序来完成每一个位的排序工作。

## 思考

1.冒泡排序和插入排序的时间复杂度都是 O(n2)，都是原地排序算法，为什么插入排序要比冒泡排序更受欢迎呢？

答：从代码实现上来看，冒泡排序的数据交换要比插入排序的数据移动要复杂，冒泡排序需要 3 个赋值操作，而插入排序只需要 1 个。插入排序的算法思路也有很大的优化空间，比如希尔排序。

## 资料

[算法可视化](https://visualgo.net/zh/sorting)